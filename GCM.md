# GCM Protocol (Galois/Counter Mode) Documentation

GCM (Galois/Counter Mode) is a widely used authenticated encryption mode that simultaneously provides confidentiality and data integrity. This document explains the GCM protocol in detail, its underlying components, and the flow of operations—with visual aids and icons to help students understand each step.

---

## 📷 GCM Protocol Diagram

<div style="text-align: center;">
  <img src="https://github.com/user-attachments/assets/154ca1b2-3864-46dd-b74c-db50fbe7f189" style="background-color: white;" alt="GCM Protocol Diagram">
</div>

---

## 📝 Explanation of the Diagram

This diagram gives a visual overview of the GCM protocol, showing how encryption and authentication work together:

- **🔑 Initialization Vector (IV) Integration:**  
  The IV is a unique nonce used to derive the initial counter block. For optimal performance, a 96-bit IV is recommended. It is concatenated with a fixed suffix (typically 31 zero bits followed by a 1) to form the starting counter value.

- **🔐 Counter Mode Encryption (CTR):**  
  Successive counter blocks are generated by incrementing the initial counter value. Each counter block is encrypted using a block cipher (like AES), producing a pseudorandom keystream that is then XORed with the plaintext to generate the ciphertext.

- **🛡️ GHASH Authentication:**  
  In parallel with encryption, the ciphertext and any additional authenticated data (AAD) are fed into the GHASH function:
  - **Data Preparation:** The ciphertext and AAD are split into 128-bit blocks (with padding applied if necessary).
  - **Hash Subkey Generation:** A subkey `H` is computed by encrypting an all-zero 128-bit block with the encryption key.
  - **Iterative Processing:** Starting with an initial value of zero, each data block is combined (using XOR) and multiplied by `H` in the finite field GF(2^128). This iterative process produces a single 128-bit authentication value.
  - **Tag Formation:** This authentication value is then mixed with an encrypted counter block (derived from the IV) to form the final authentication tag.

- **📦 Output Combination:**  
  The final output includes both the ciphertext and the authentication tag. This ensures that the recipient can verify the data’s integrity and authenticity while decrypting it.

---

## 📚 Key Concepts

- **Authenticated Encryption:**  
  GCM offers both encryption (to protect the data's confidentiality) and authentication (to ensure the data has not been modified).

- **Parallel Processing:**  
  Both the counter mode encryption and GHASH computations are highly parallelizable, enabling high throughput—critical for modern network applications.

- **Finite Field Arithmetic:**  
  GHASH operates in GF(2^128) using operations such as XOR (for addition) and specialized multiplication modulo an irreducible polynomial (typically `x^128 + x^7 + x^2 + x + 1`). This mathematical approach ensures that even tiny changes in the input produce a dramatically different authentication output.

---

## ⚙️ Detailed Operation

### 1. Inputs
- **Secret Key (K):**  
  The encryption key used with the block cipher (e.g., AES).
- **Initialization Vector (IV):**  
  A unique nonce (ideally 96 bits) that ensures each encryption operation is unique.
- **Plaintext (P):**  
  The original data to be encrypted.
- **Additional Authenticated Data (AAD):**  
  Data that is authenticated (its integrity is verified) but not encrypted (e.g., header information).

### 2. Preprocessing
- **Hash Subkey (H):**  
  Compute the hash subkey by encrypting an all-zero 128-bit block:

**H = AES(K, 0^128)**

This subkey is then used in the GHASH function.

### 3. Encryption (CTR Mode)
- **Block Division & Counter Generation:**  
  The plaintext is split into 128-bit blocks. A counter is generated from the IV (as explained above) and incremented for each block.
- **Keystream Generation:**  
  Each counter block is encrypted with AES to generate a keystream.
- **Ciphertext Production:**  
  Each plaintext block is XORed with the corresponding keystream block, producing the ciphertext.

### 4. GHASH Authentication

**Purpose (Why We Need GHASH):**  
Think of GHASH like a “fingerprint” maker for your encrypted data. It guarantees that if anyone changes even a single bit of the ciphertext or the associated data (AAD), the fingerprint will no longer match. This lets the receiver detect any tampering.

**Detailed Process (How GHASH Works):**

1. **Data Preparation**  
   - The ciphertext (the encrypted message) and any AAD (extra data you want protected, such as headers) are cut into 128-bit pieces.  
   - If a piece is shorter than 128 bits, zeros are added to make it a full block.

2. **Hash Subkey Calculation**  
   - Earlier in the GCM process, we generated a special key called `H`. GHASH uses this key for all its calculations.  
   - You can think of `H` as a unique ingredient that ensures your “fingerprint” is tied to the main encryption key.

3. **Iterative Computation**  
   - Start with an initial value, `Y₀ = 0`.  
   - For each 128-bit block \(S_i\) (whether it’s part of the AAD or the ciphertext, plus one extra block that stores their lengths), do this:
     \[
       Y_i = (Y_{i-1} \oplus S_i) \cdot H
     \]
     - **\(\oplus\)** means XOR, which is like a bitwise “add without carrying.”
     - **\(\cdot\)** means multiplication in a special math system called **GF(2^128)** (Galois Field).

   - **What is GF(2^128)?**  
     - **GF(2^128)** is a finite field containing exactly \(2^{128}\) elements, where each element is represented as a 128-bit binary number.  
     - **Addition in GF(2^128):**  
       Instead of normal addition, numbers are added using the XOR operation. This means that each bit is added without carrying over to the next bit.  
     - **Multiplication in GF(2^128):**  
       Multiplication is done by treating the 128-bit numbers as polynomials with coefficients in GF(2) (each coefficient is 0 or 1). The product is then reduced modulo an irreducible polynomial (commonly \(x^{128} + x^7 + x^2 + x + 1\)), ensuring the result remains a 128-bit number.  
     - **Why It Matters:**  
       This special kind of multiplication mixes the bits thoroughly so that even a tiny change in the input produces a completely different result—a property that is essential for detecting any tampering with the data.

4. **Authentication Tag Generation**  
   - After processing every block, the final GHASH result (the combined fingerprint) is **XORed** with an **encrypted counter block** (derived from the IV).  
   - The output of this step is then shortened (truncated) to produce the final **authentication tag** (often called “tag” or “ICV”).  
   - When the receiver decrypts, they redo this GHASH process; if the tag they get matches the one sent, they know nothing was changed in transit.

---

### 5. Output

- **Ciphertext (C):**  
  The encrypted version of the original plaintext. If an attacker can’t break the encryption key, they can’t read the contents.

- **Authentication Tag (T):**  
  A small piece of data (often 16 bytes or less) that proves the ciphertext and AAD haven’t been tampered with. If even one bit of the message changes, the tag won’t match.

---
## 🗺️ Mermaid Diagram of GCM Flow

```mermaid
flowchart TD
    A[Start] --> B[Input: Key, IV, Plaintext, AAD]
    B --> C[Compute Hash Subkey<br>H = AES- K, 0^128]
    C --> D[Divide Plaintext into 128-bit Blocks]
    D --> E[Generate Counter Blocks<br>from IV & Increment Function]
    E --> F[Encrypt Counters with AES<br>to Create Keystream]
    F --> G[Produce Ciphertext:<br>P XOR Keystream]
    G --> H[Process AAD & Ciphertext<br>through GHASH]
    H --> I[Combine GHASH Output with<br>Encrypted Counter to Form Tag]
    I --> J[Output: Ciphertext & Authentication Tag]
    J --> K[End]
```


