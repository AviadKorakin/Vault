# GCM Protocol (Galois/Counter Mode) Documentation

GCM (Galois/Counter Mode) is a widely used authenticated encryption mode that simultaneously provides confidentiality and data integrity. This document explains the GCM protocol in detail, its underlying components, and the flow of operations—with visual aids and icons to help students understand each step.

---

## 📷 GCM Protocol Diagram

<div style="text-align: center;">
  <img src="https://github.com/user-attachments/assets/154ca1b2-3864-46dd-b74c-db50fbe7f189" style="background-color: white;" alt="GCM Protocol Diagram">
</div>

---

## 📝 Explanation of the Diagram

This diagram gives a visual overview of the GCM protocol, showing how encryption and authentication work together:

- **🔑 Initialization Vector (IV) Integration:**  
  The IV is a unique nonce used to derive the initial counter block. For optimal performance, a 96-bit IV is recommended. It is concatenated with a fixed suffix (typically 31 zero bits followed by a 1) to form the starting counter value.

- **🔐 Counter Mode Encryption (CTR):**  
  Successive counter blocks are generated by incrementing the initial counter value. Each counter block is encrypted using a block cipher (like AES), producing a pseudorandom keystream that is then XORed with the plaintext to generate the ciphertext.

- **🛡️ GHASH Authentication:**  
  In parallel with encryption, the ciphertext and any additional authenticated data (AAD) are fed into the GHASH function:
  - **Data Preparation:** The ciphertext and AAD are split into 128-bit blocks (with padding applied if necessary).
  - **Hash Subkey Generation:** A subkey `H` is computed by encrypting an all-zero 128-bit block with the encryption key.
  - **Iterative Processing:** Starting with an initial value of zero, each data block is combined (using XOR) and multiplied by `H` in the finite field GF(2^128). This iterative process produces a single 128-bit authentication value.
  - **Tag Formation:** This authentication value is then mixed with an encrypted counter block (derived from the IV) to form the final authentication tag.

- **📦 Output Combination:**  
  The final output includes both the ciphertext and the authentication tag. This ensures that the recipient can verify the data’s integrity and authenticity while decrypting it.

---

## 📚 Key Concepts

- **Authenticated Encryption:**  
  GCM offers both encryption (to protect the data's confidentiality) and authentication (to ensure the data has not been modified).

- **Parallel Processing:**  
  Both the counter mode encryption and GHASH computations are highly parallelizable, enabling high throughput—critical for modern network applications.

- **Finite Field Arithmetic:**  
  GHASH operates in GF(2^128) using operations such as XOR (for addition) and specialized multiplication modulo an irreducible polynomial (typically `x^128 + x^7 + x^2 + x + 1`). This mathematical approach ensures that even tiny changes in the input produce a dramatically different authentication output.

---

## ⚙️ Detailed Operation

### 1. Inputs

- **Secret Key (K):**  
  The encryption key used with the block cipher (e.g., AES).

- **Initialization Vector (IV):**  
  A unique nonce (ideally 96 bits) that ensures each encryption operation is unique.

- **Plaintext (P):**  
  The original data to be encrypted.

- **Additional Authenticated Data (AAD):**  
  Data that is not encrypted but is still authenticated. AAD typically includes protocol headers, metadata, timestamps, or any other associated information that must remain in plaintext while still being protected against tampering. During the authentication process, AAD is processed alongside the ciphertext within the GHASH function so that any modifications to this data can be detected upon decryption.

### 2. Preprocessing
- **Hash Subkey (H):**  
  Compute the hash subkey by encrypting an all-zero 128-bit block:

**H = AES(K, 0^128)**

This subkey is then used in the GHASH function.

### 3. Encryption (CTR Mode)
- **Block Division & Counter Generation:**  
  The plaintext is split into 128-bit blocks. A counter is generated from the IV (as explained above) and incremented for each block.
- **Keystream Generation:**  
  Each counter block is encrypted with AES to generate a keystream.
- **Ciphertext Production:**  
  Each plaintext block is XORed with the corresponding keystream block, producing the ciphertext.

### 4. GHASH Authentication

**Purpose (Why We Need GHASH):**  
Think of GHASH like a “fingerprint” maker for your encrypted data. It guarantees that if anyone changes even a single bit of the ciphertext or the associated data (AAD), the fingerprint will no longer match. This lets the receiver detect any tampering.

**Detailed Process (How GHASH Works):**

1. **Data Preparation**  
   - The ciphertext (the encrypted message) and any AAD (extra data you want protected, such as headers) are cut into 128-bit pieces.  
   - If a piece is shorter than 128 bits, zeros are added to make it a full block.

2. **Hash Subkey Calculation**  
   - Earlier in the GCM process, we generated a special key called `H`. GHASH uses this key for all its calculations.  
   - You can think of `H` as a unique ingredient that ensures your “fingerprint” is tied to the main encryption key.

Below is the revised Markdown content with fixes to the functions so that the math displays correctly. In this version, I’ve replaced the display math delimiters with double dollar signs for better compatibility, while keeping the code and structure intact:

---

### 1. Inputs

- **Secret Key (K):**  
  The encryption key used with the block cipher (e.g., AES).

- **Initialization Vector (IV):**  
  A unique nonce (ideally 96 bits) that ensures each encryption operation is unique.

- **Plaintext (P):**  
  The original data to be encrypted.

- **Additional Authenticated Data (AAD):**  
  Data that is not encrypted but is still authenticated. AAD typically includes protocol headers, metadata, timestamps, or any other associated information that must remain in plaintext while still being protected against tampering. During the authentication process, AAD is processed alongside the ciphertext within the GHASH function so that any modifications to this data can be detected upon decryption.

---

### 3. Iterative Computation
- **Initial Value:**  
  Start with an initial value, `Y₀ = 0`.

- **Block Processing:**  
  For each 128-bit block \(S_i\) (covering blocks derived from both the AAD and the ciphertext, plus one extra block that encodes their lengths), compute:
  
  $$
  Y_i = (Y_{i-1} \oplus S_i) \cdot H
  $$

  where:
- **$$\oplus$$** represents the XOR operator (a bitwise “add without carrying”).
- **$$\cdot$$** denotes multiplication in the finite field GF(2^128).


- **Understanding GF(2^128):**
  - **Finite Field:**  
    GF(2^128) is a finite field containing exactly \(2^{128}\) elements, where each element is represented as a 128-bit binary number.
  - **Addition in GF(2^128):**  
    Instead of standard addition, numbers are added using the XOR operation—each bit is added without carrying.
  - **Multiplication in GF(2^128):**  
    Multiplication is performed by treating the 128-bit numbers as polynomials with coefficients in GF(2) (each coefficient being 0 or 1). The resulting product is then reduced modulo an irreducible polynomial (commonly \(x^{128} + x^7 + x^2 + x + 1\)), ensuring the result remains a 128-bit number.
  - **Why It Matters:**  
    This method thoroughly mixes the bits so that even a tiny change in the input produces a dramatically different output—a key property for detecting any tampering with the data.

---

### 4. Authentication Tag Generation
- After processing every block, the final GHASH result (the combined fingerprint) is **XORed** with an **encrypted counter block** (derived from the IV).
- The output of this step is then shortened (truncated) to produce the final **authentication tag** (often called “tag” or “ICV”).
- When the receiver decrypts, they re-run the GHASH process; if the tag they compute matches the one sent, it verifies that the data has not been altered.

---

This updated version should now display the functions correctly in your file.

### 5. Output

- **Ciphertext (C):**  
  The encrypted version of the original plaintext. If an attacker can’t break the encryption key, they can’t read the contents.

- **Authentication Tag (T):**  
  A small piece of data (often 16 bytes or less) that proves the ciphertext and AAD haven’t been tampered with. If even one bit of the message changes, the tag won’t match.

---
## 🗺️ Mermaid Diagram of GCM Flow

```mermaid
flowchart TD
    A[Start] --> B[Input: Key, IV, Plaintext, AAD]
    B --> C[Compute Hash Subkey<br>H = AES- K, 0^128]
    C --> D[Divide Plaintext into 128-bit Blocks]
    D --> E[Generate Counter Blocks<br>from IV & Increment Function]
    E --> F[Encrypt Counters with AES<br>to Create Keystream]
    F --> G[Produce Ciphertext:<br>P XOR Keystream]
    G --> H[Process AAD & Ciphertext<br>through GHASH]
    H --> I[Combine GHASH Output with<br>Encrypted Counter to Form Tag]
    I --> J[Output: Ciphertext & Authentication Tag]
    J --> K[End]
```


