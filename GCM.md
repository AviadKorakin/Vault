```markdown
# GCM Protocol (Galois/Counter Mode) Documentation

GCM (Galois/Counter Mode) is a widely used authenticated encryption mode that simultaneously provides confidentiality and data integrity. This document explains the GCM protocol in detail, its underlying components, and the flow of operationsâ€”with visual aids and icons to help students understand each step.

---

## ðŸ“· GCM Protocol Diagram

<div style="text-align: center;">
  <img src="https://github.com/user-attachments/assets/154ca1b2-3864-46dd-b74c-db50fbe7f189" style="background-color: white;" alt="GCM Protocol Diagram">
</div>

---

## ðŸ“ Explanation of the Diagram

This diagram gives a visual overview of the GCM protocol, showing how encryption and authentication work together:

- **ðŸ”‘ Initialization Vector (IV) Integration:**  
  The IV is a unique nonce used to derive the initial counter block. For optimal performance, a 96-bit IV is recommended. It is concatenated with a fixed suffix (typically 31 zero bits followed by a 1) to form the starting counter value.

- **ðŸ” Counter Mode Encryption (CTR):**  
  Successive counter blocks are generated by incrementing the initial counter value. Each counter block is encrypted using a block cipher (like AES), producing a pseudorandom keystream that is then XORed with the plaintext to generate the ciphertext.

- **ðŸ›¡ï¸ GHASH Authentication:**  
  In parallel with encryption, the ciphertext and any additional authenticated data (AAD) are fed into the GHASH function:
  - **Data Preparation:** The ciphertext and AAD are split into 128-bit blocks (with padding applied if necessary).
  - **Hash Subkey Generation:** A subkey `H` is computed by encrypting an all-zero 128-bit block with the encryption key.
  - **Iterative Processing:** Starting with an initial value of zero, each data block is combined (using XOR) and multiplied by `H` in the finite field GF(2^128). This iterative process produces a single 128-bit authentication value.
  - **Tag Formation:** This authentication value is then mixed with an encrypted counter block (derived from the IV) to form the final authentication tag.

- **ðŸ“¦ Output Combination:**  
  The final output includes both the ciphertext and the authentication tag. This ensures that the recipient can verify the dataâ€™s integrity and authenticity while decrypting it.

---

## ðŸ“š Key Concepts

- **Authenticated Encryption:**  
  GCM offers both encryption (to protect the data's confidentiality) and authentication (to ensure the data has not been modified).

- **Parallel Processing:**  
  Both the counter mode encryption and GHASH computations are highly parallelizable, enabling high throughputâ€”critical for modern network applications.

- **Finite Field Arithmetic:**  
  GHASH operates in GF(2^128) using operations such as XOR (for addition) and specialized multiplication modulo an irreducible polynomial (typically `x^128 + x^7 + x^2 + x + 1`). This mathematical approach ensures that even tiny changes in the input produce a dramatically different authentication output.

---

## âš™ï¸ Detailed Operation

### 1. Inputs
- **Secret Key (K):**  
  The encryption key used with the block cipher (e.g., AES).
- **Initialization Vector (IV):**  
  A unique nonce (ideally 96 bits) that ensures each encryption operation is unique.
- **Plaintext (P):**  
  The original data to be encrypted.
- **Additional Authenticated Data (AAD):**  
  Data that is authenticated (its integrity is verified) but not encrypted (e.g., header information).

### 2. Preprocessing
- **Hash Subkey (H):**  
  Compute the hash subkey by encrypting an all-zero 128-bit block:
  ```
H = AES(K, 0^128)
  ```
  This subkey is then used in the GHASH function.

### 3. Encryption (CTR Mode)
- **Block Division & Counter Generation:**  
  The plaintext is split into 128-bit blocks. A counter is generated from the IV (as explained above) and incremented for each block.
- **Keystream Generation:**  
  Each counter block is encrypted with AES to generate a keystream.
- **Ciphertext Production:**  
  Each plaintext block is XORed with the corresponding keystream block, producing the ciphertext.

### 4. GHASH Authentication
- **Purpose:**  
  GHASH is used to ensure that the ciphertext and AAD remain unaltered.
- **Detailed Process:**  
  1. **Data Preparation:**  
     - The ciphertext and AAD are divided into 128-bit blocks. Incomplete blocks are padded with zeros.
  2. **Hash Subkey Calculation:**  
     - The hash subkey `H` (calculated earlier) is used for all subsequent operations.
  3. **Iterative Computation:**  
     - Begin with `Y0 = 0`. For each block `Si` (which includes all AAD blocks, ciphertext blocks, and a block encoding the lengths of AAD and ciphertext), compute:
       ```
       Yi = (Yi-1 âŠ• Si) Â· H
       ```
       where the multiplication is carried out in the finite field GF(2^128).
  4. **Authentication Tag Generation:**  
     - The final value, after processing all blocks, is combined with an encrypted counter block (derived from the IV) and truncated to produce the authentication tag `T`.

### 5. Output
- **Ciphertext (C):**  
  The encrypted version of the plaintext.
- **Authentication Tag (T):**  
  A tag that verifies the integrity and authenticity of both the ciphertext and AAD.

---

## ðŸ—ºï¸ Mermaid Diagram of GCM Flow

```mermaid
flowchart TD
    A[Start] --> B[Input: Key, IV, Plaintext, AAD]
    B --> C[Compute Hash Subkey<br>H = AES(K, 0^128)]
    C --> D[Divide Plaintext into 128-bit Blocks]
    D --> E[Generate Counter Blocks<br>from IV & Increment Function]
    E --> F[Encrypt Counters with AES<br>to Create Keystream]
    F --> G[Produce Ciphertext:<br>P XOR Keystream]
    G --> H[Process AAD & Ciphertext<br>through GHASH]
    H --> I[Combine GHASH Output with<br>Encrypted Counter to Form Tag]
    I --> J[Output: Ciphertext & Authentication Tag]
    J --> K[End]
```


