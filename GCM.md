```markdown
# GCM Protocol (Galois/Counter Mode) Documentation

GCM (Galois/Counter Mode) is a widely used authenticated encryption mode that simultaneously provides confidentiality and data integrity. This document explains the GCM protocol in detail, its underlying components, and the flow of operations—with visual aids and icons to help students understand each step.

---

## 📷 GCM Protocol Diagram

<div style="text-align: center;">
  <img src="https://github.com/user-attachments/assets/154ca1b2-3864-46dd-b74c-db50fbe7f189" style="background-color: white;" alt="GCM Protocol Diagram">
</div>

---

## 📝 Explanation of the Diagram

This diagram gives a visual overview of the GCM protocol, showing how encryption and authentication work together:

- **🔑 Initialization Vector (IV) Integration:**  
  The IV is a unique nonce used to derive the initial counter block. For optimal performance, a 96-bit IV is recommended. It is concatenated with a fixed suffix (typically 31 zero bits followed by a 1) to form the starting counter value.

- **🔐 Counter Mode Encryption (CTR):**  
  Successive counter blocks are generated by incrementing the initial counter value. Each counter block is encrypted using a block cipher (like AES), producing a pseudorandom keystream that is then XORed with the plaintext to generate the ciphertext.

- **🛡️ GHASH Authentication:**  
  In parallel with encryption, the ciphertext and any additional authenticated data (AAD) are fed into the GHASH function:
  - **Data Preparation:** The ciphertext and AAD are split into 128-bit blocks (with padding applied if necessary).
  - **Hash Subkey Generation:** A subkey `H` is computed by encrypting an all-zero 128-bit block with the encryption key.
  - **Iterative Processing:** Starting with an initial value of zero, each data block is combined (using XOR) and multiplied by `H` in the finite field GF(2^128). This iterative process produces a single 128-bit authentication value.
  - **Tag Formation:** This authentication value is then mixed with an encrypted counter block (derived from the IV) to form the final authentication tag.

- **📦 Output Combination:**  
  The final output includes both the ciphertext and the authentication tag. This ensures that the recipient can verify the data’s integrity and authenticity while decrypting it.

---

## 📚 Key Concepts

- **Authenticated Encryption:**  
  GCM offers both encryption (to protect the data's confidentiality) and authentication (to ensure the data has not been modified).

- **Parallel Processing:**  
  Both the counter mode encryption and GHASH computations are highly parallelizable, enabling high throughput—critical for modern network applications.

- **Finite Field Arithmetic:**  
  GHASH operates in GF(2^128) using operations such as XOR (for addition) and specialized multiplication modulo an irreducible polynomial (typically `x^128 + x^7 + x^2 + x + 1`). This mathematical approach ensures that even tiny changes in the input produce a dramatically different authentication output.

---

## ⚙️ Detailed Operation

### 1. Inputs
- **Secret Key (K):**  
  The encryption key used with the block cipher (e.g., AES).
- **Initialization Vector (IV):**  
  A unique nonce (ideally 96 bits) that ensures each encryption operation is unique.
- **Plaintext (P):**  
  The original data to be encrypted.
- **Additional Authenticated Data (AAD):**  
  Data that is authenticated (its integrity is verified) but not encrypted (e.g., header information).

### 2. Preprocessing
- **Hash Subkey (H):**  
  Compute the hash subkey by encrypting an all-zero 128-bit block:
  ```
H = AES(K, 0^128)
  ```
  This subkey is then used in the GHASH function.

### 3. Encryption (CTR Mode)
- **Block Division & Counter Generation:**  
  The plaintext is split into 128-bit blocks. A counter is generated from the IV (as explained above) and incremented for each block.
- **Keystream Generation:**  
  Each counter block is encrypted with AES to generate a keystream.
- **Ciphertext Production:**  
  Each plaintext block is XORed with the corresponding keystream block, producing the ciphertext.

### 4. GHASH Authentication
- **Purpose:**  
  GHASH is used to ensure that the ciphertext and AAD remain unaltered.
- **Detailed Process:**  
  1. **Data Preparation:**  
     - The ciphertext and AAD are divided into 128-bit blocks. Incomplete blocks are padded with zeros.
  2. **Hash Subkey Calculation:**  
     - The hash subkey `H` (calculated earlier) is used for all subsequent operations.
  3. **Iterative Computation:**  
     - Begin with `Y0 = 0`. For each block `Si` (which includes all AAD blocks, ciphertext blocks, and a block encoding the lengths of AAD and ciphertext), compute:
       ```
       Yi = (Yi-1 ⊕ Si) · H
       ```
       where the multiplication is carried out in the finite field GF(2^128).
  4. **Authentication Tag Generation:**  
     - The final value, after processing all blocks, is combined with an encrypted counter block (derived from the IV) and truncated to produce the authentication tag `T`.

### 5. Output
- **Ciphertext (C):**  
  The encrypted version of the plaintext.
- **Authentication Tag (T):**  
  A tag that verifies the integrity and authenticity of both the ciphertext and AAD.

---

## 🗺️ Mermaid Diagram of GCM Flow

```mermaid
flowchart TD
    A[Start] --> B[Input: Key, IV, Plaintext, AAD]
    B --> C[Compute Hash Subkey<br>H = AES(K, 0^128)]
    C --> D[Divide Plaintext into 128-bit Blocks]
    D --> E[Generate Counter Blocks<br>from IV & Increment Function]
    E --> F[Encrypt Counters with AES<br>to Create Keystream]
    F --> G[Produce Ciphertext:<br>P XOR Keystream]
    G --> H[Process AAD & Ciphertext<br>through GHASH]
    H --> I[Combine GHASH Output with<br>Encrypted Counter to Form Tag]
    I --> J[Output: Ciphertext & Authentication Tag]
    J --> K[End]
```


